<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Shalutha's Blog]]></title><description><![CDATA[Thoughts, stories and ideas.]]></description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Shalutha&apos;s Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 3.40</generator><lastBuildDate>Sun, 21 Mar 2021 14:23:26 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Writing your own path planning algorithm in ROS]]></title><description><![CDATA[In this article I will focus on writing and adding D* Lite algorithm as a path planner plugin in ROS, so that you can try out your customized path planning algorithms and evaluate their performance in ROS simulation environment before going into the real world.]]></description><link>http://localhost:2368/writing-your-own-path-planning-algorithm-in-ros-2/</link><guid isPermaLink="false">605740a55143f80a507e5ddb</guid><dc:creator><![CDATA[Shalutha Rajapakshe]]></dc:creator><pubDate>Thu, 18 Mar 2021 12:52:00 GMT</pubDate><media:content url="http://localhost:2368/content/images/2021/03/post-image.jpg" medium="image"/><content:encoded><![CDATA[<img src="http://localhost:2368/content/images/2021/03/post-image.jpg" alt="Writing your own path planning algorithm in ROS"><p>Path planning is an important and a significant area in the robotics field. Mobile robots are capable of finding an optimal or a near optimal path from the starting location to a destination based on metrics such as shortest way, quickest way, easiest way, etc. while avoiding collision with obstacles in the operating environment.</p><p>According to the level of information known about the operating environment, path planning can be mainly divided into two types.</p><p>1. <strong>Path planning based on global map information</strong></p><blockquote>This is called global path planning and the information about the operating environment should be completely known for this. In other words, a map should be needed for global path planning.</blockquote><p>2.<strong> Path planning based on local map information</strong></p><blockquote>This is called local path planning. Local path planning focuses on the information observed through the sensors of the robot to find a path from starting location to destination while avoiding obstacles.</blockquote><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/800/1*HgHYCLD1KvaC06oSITRrJQ.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"><figcaption>Global plan given by global planner &amp; local plan given by local&nbsp;planner</figcaption></figure><p>What usually happens is first we give our robot a map that we previously built. Map building is a broad field and I will skip that part here. Usually <strong>Simultaneous Localization and Mapping(SLAM)</strong> is used for map building and there are several SLAM methods like <strong>gmapping</strong>, <strong>Hector slam</strong>, <strong>wild-cat slam</strong>, etc. can be used for that purpose.</p><p>So when we have our map, the global path planning algorithm will use that map to generate paths from point to point on that map. It doesn’t care about the sensor information or doesn’t know about new obstacles appearing within the map after the map creation instance, it only uses the static map given for it to calculate the paths. So we cannot only use the global path planning for navigation if our environment is dynamic which is more often the common thing in real world applications.</p><p>This is where local path planning comes into play. Now the robot has a map and a path to follow to its destination. While following the path given from the global path planner, the local path planner will collect information from its sensors and recalculate paths, avoiding any newly appeared or dynamic obstacles within its sensor range. Or in other words the local planner creates his own small map according to the sensor information and uses it for navigation.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/800/1*xo6QCKPBn0fmmuwWSDt3EA.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"><figcaption>Static map given to the global planner &amp; Local map created by sensor information</figcaption></figure><p>So in this way the global path planning and local path planning achieves navigation.</p><hr><p><strong>Robot Operating System(ROS)</strong> is an open source framework for writing software related to robots. It includes a collection of tools, libraries and conventions which targets to simplify the creation of complex robot applications across a wide variety of robotic platforms. The amount of robots that use ROS in the scientific community and industry are growing very fast. The built-in ROS simulator <strong>Gazebo</strong> is a widely used simulator in all over the world. It also comes with a physical engine for gravity, inertia, illumination etc. for a real world experience. Even NASA uses this simulator to simulate their robots used for planetary exploration. In this article I will focus on writing and adding D* Lite algorithm as a path planner plugin in ROS, so that you can try out your customized path planning algorithms and evaluate their performance in ROS simulation environment before going into the real world.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*U2HhTNFTipyZESd-NeU7LA.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>I followed this excellent <a href="http://wiki.ros.org/navigation/Tutorials/Writing%20A%20Global%20Path%20Planner%20As%20Plugin%20in%20ROS" rel="noopener"><strong>tutorial </strong></a>written by Dr. Anis Kouba in ROS wiki regarding the integration of a <strong>global path planner plugin</strong> in ROS. So the steps are as below for ROS Noetic version.</p><hr><p>First of all, lets create a new ROS package with required dependencies. The global path planner we are writing must adhere to <strong>nav_core::BaseGlobalPlanner</strong> which is a C++ interface in <strong>nav_core</strong> package that includes key interfaces for the navigation stack. So our package must depend on nav_core. Other than that our package must depend on <strong>roscpp</strong>; which provides a library to interface ROS with C++,<strong> rospy</strong>; which provides a library to interface ROS with python and <strong>std_msgs</strong>; which includes standard ROS messages used in ROS communication. Don’t worry if you forgot to include any of these dependent packages at the beginning, you can always add necessary dependencies later onwards because sometimes we cannot exactly say these are the only packages we require for our work. But for today, we will include the necessary dependencies at the package creating instance. So open a new terminal, go to your workspace’s “<strong>src”</strong> folder and write the following command in the terminal to create your new path planner package. Since I’m creating a D*lite planner I will name my package as dstar_lite_planner</p><blockquote><strong><em>catkin_create_pkg dstar_lite_planner nav_core roscpp rospy std_msgs</em></strong></blockquote><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*dAaUpsXC0Q2YZdyRSnAjPg.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>Now your package has been created. Now it’s time to write the path planner class which is needed for our planner. Go to the “<strong>src</strong>” folder inside your package and create a new header file and a source file. You can give any name you want.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*pu1zPkTXL7Sm_hD-dMNkHA.gif" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>I have provided two template files added with some comments that uses D* lite algorithm for global path planning. You can use those files to write your own path planner algorithm. You just have to fill the necessary functions in order to make it work. A proper explanation about the content of these files can be found from Dr. Anis Kouba’s tutorial I mentioned earlier. and finally the output path should be given as a vector.</p><p>You can find the template files from my <a href="https://github.com/ShaluthaRajapakshe/dstar_lite_planner.git" rel="noopener"><strong>Github</strong></a> repo.</p><p>Now we have completed writing our global path planner class. So we should compile it now. For that, add the following line to your newly created package’s <strong>CMakeLists.txt </strong>file.</p><!--kg-card-begin: html--><script src="https://gist.github.com/ShaluthaRajapakshe/e394818c25b285ddfcd573b00d40b3d7.js"></script>
<!--kg-card-end: html--><p>Then in terminal go to catkin_ws directory and run catkin_make. Now you can see your library file created at the directory: <strong>/catkin_ws/devel/lib </strong>with the name<strong> libd_star_planner.so</strong></p><p>Now it is time to deploy our path planner as a plugin in ROS. For that first we should create the plugin description file, inside the package we created.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*c1941w9Jpf6XqgZ9pN_5IA.gif" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>Then the information about your plugin should be added to that file. Add the following information according to your planner’s details inside the plugin description file.</p><!--kg-card-begin: html--><script src="https://gist.github.com/ShaluthaRajapakshe/f4d5e8cea2304c85e6fe736e69725c27.js"></script><!--kg-card-end: html--><p>Congratulations!. Now you have successfully deployed your path planner plugin in the ROS environment. For verification, type this command in your terminal and see whether your plugin is shown.</p><blockquote><strong>rospack plugins — attrib=plugin nav_core</strong></blockquote><p>Now you can add this plugin to any of your robot’s navigation stack and use it for navigation purposes. What you have to do is add the planner as shown in the following image as one your move_base package’s parameters.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*afSjmAClyHfhWlXiyj1cJQ.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>In a future article I will explain the steps to add this plugin on Turtlebot3 - Waffle which is a famous robot among the ROS community.</p>]]></content:encoded></item></channel></rss>