<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="https://purl.org/dc/elements/1.1/" xmlns:content="https://purl.org/rss/1.0/modules/content/" xmlns:atom="https://www.w3.org/2005/Atom" version="2.0" xmlns:media="https://search.yahoo.com/mrss/"><channel><title><![CDATA[Shalutha's Blog]]></title><description><![CDATA[Thoughts, stories and ideas.]]></description><link>https://shalutharajapakshe.github.io/</link><image><url>https://shalutharajapakshe.github.io/favicon.png</url><title>Shalutha&apos;s Blog</title><link>https://shalutharajapakshe.github.io/</link></image><generator>Ghost 3.40</generator><lastBuildDate>Sun, 13 Jun 2021 17:53:57 GMT</lastBuildDate><atom:link href="https://shalutharajapakshe.github.io/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Writing your own path planning algorithm in ROS]]></title><description><![CDATA[In this article I will focus on writing and adding D* Lite algorithm as a path planner plugin in ROS, so that you can try out your customized path planning algorithms and evaluate their performance in ROS simulation environment before going into the real world.]]></description><link>https://shalutharajapakshe.github.io/writing-your-own-path-planning-algorithm-in-ros-2/</link><guid isPermaLink="false">605740a55143f80a507e5ddb</guid><category><![CDATA[Robotics]]></category><dc:creator><![CDATA[Shalutha Rajapakshe]]></dc:creator><pubDate>Thu, 18 Mar 2021 12:52:00 GMT</pubDate><media:content url="https://shalutharajapakshe.github.io/content/images/2021/03/post-image.jpg" medium="image"/><content:encoded><![CDATA[<img src="https://shalutharajapakshe.github.io/content/images/2021/03/post-image.jpg" alt="Writing your own path planning algorithm in ROS"><p>Path planning is an important and a significant area in the robotics field. Mobile robots are capable of finding an optimal or a near optimal path from the starting location to a destination based on metrics such as shortest way, quickest way, easiest way, etc. while avoiding collision with obstacles in the operating environment.</p><p>According to the level of information known about the operating environment, path planning can be mainly divided into two types.</p><p>1. <strong>Path planning based on global map information</strong></p><blockquote>This is called global path planning and the information about the operating environment should be completely known for this. In other words, a map should be needed for global path planning.</blockquote><p>2.<strong> Path planning based on local map information</strong></p><blockquote>This is called local path planning. Local path planning focuses on the information observed through the sensors of the robot to find a path from starting location to destination while avoiding obstacles.</blockquote><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/800/1*HgHYCLD1KvaC06oSITRrJQ.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"><figcaption>Global plan given by global planner &amp; local plan given by local&nbsp;planner</figcaption></figure><p>What usually happens is first we give our robot a map that we previously built. Map building is a broad field and I will skip that part here. Usually <strong>Simultaneous Localization and Mapping(SLAM)</strong> is used for map building and there are several SLAM methods like <strong>gmapping</strong>, <strong>Hector slam</strong>, <strong>wild-cat slam</strong>, etc. can be used for that purpose.</p><p>So when we have our map, the global path planning algorithm will use that map to generate paths from point to point on that map. It doesn’t care about the sensor information or doesn’t know about new obstacles appearing within the map after the map creation instance, it only uses the static map given for it to calculate the paths. So we cannot only use the global path planning for navigation if our environment is dynamic which is more often the common thing in real world applications.</p><p>This is where local path planning comes into play. Now the robot has a map and a path to follow to its destination. While following the path given from the global path planner, the local path planner will collect information from its sensors and recalculate paths, avoiding any newly appeared or dynamic obstacles within its sensor range. Or in other words the local planner creates his own small map according to the sensor information and uses it for navigation.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://cdn-images-1.medium.com/max/800/1*xo6QCKPBn0fmmuwWSDt3EA.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"><figcaption>Static map given to the global planner &amp; Local map created by sensor information</figcaption></figure><p>So in this way the global path planning and local path planning achieves navigation.</p><hr><p><strong>Robot Operating System(ROS)</strong> is an open source framework for writing software related to robots. It includes a collection of tools, libraries and conventions which targets to simplify the creation of complex robot applications across a wide variety of robotic platforms. The amount of robots that use ROS in the scientific community and industry are growing very fast. The built-in ROS simulator <strong>Gazebo</strong> is a widely used simulator in all over the world. It also comes with a physical engine for gravity, inertia, illumination etc. for a real world experience. Even NASA uses this simulator to simulate their robots used for planetary exploration. In this article I will focus on writing and adding D* Lite algorithm as a path planner plugin in ROS, so that you can try out your customized path planning algorithms and evaluate their performance in ROS simulation environment before going into the real world.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*U2HhTNFTipyZESd-NeU7LA.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>I followed this excellent <a href="https://wiki.ros.org/navigation/Tutorials/Writing%20A%20Global%20Path%20Planner%20As%20Plugin%20in%20ROS" rel="noopener"><strong>tutorial </strong></a>written by Dr. Anis Kouba in ROS wiki regarding the integration of a <strong>global path planner plugin</strong> in ROS. So the steps are as below for ROS Noetic version.</p><hr><p>First of all, lets create a new ROS package with required dependencies. The global path planner we are writing must adhere to <strong>nav_core::BaseGlobalPlanner</strong> which is a C++ interface in <strong>nav_core</strong> package that includes key interfaces for the navigation stack. So our package must depend on nav_core. Other than that our package must depend on <strong>roscpp</strong>; which provides a library to interface ROS with C++,<strong> rospy</strong>; which provides a library to interface ROS with python and <strong>std_msgs</strong>; which includes standard ROS messages used in ROS communication. Don’t worry if you forgot to include any of these dependent packages at the beginning, you can always add necessary dependencies later onwards because sometimes we cannot exactly say these are the only packages we require for our work. But for today, we will include the necessary dependencies at the package creating instance. So open a new terminal, go to your workspace’s “<strong>src”</strong> folder and write the following command in the terminal to create your new path planner package. Since I’m creating a D*lite planner I will name my package as dstar_lite_planner</p><blockquote><strong><em>catkin_create_pkg dstar_lite_planner nav_core roscpp rospy std_msgs</em></strong></blockquote><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*dAaUpsXC0Q2YZdyRSnAjPg.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>Now your package has been created. Now it’s time to write the path planner class which is needed for our planner. Go to the “<strong>src</strong>” folder inside your package and create a new header file and a source file. You can give any name you want.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*pu1zPkTXL7Sm_hD-dMNkHA.gif" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>I have provided two template files added with some comments that uses D* lite algorithm for global path planning. You can use those files to write your own path planner algorithm. You just have to fill the necessary functions in order to make it work. A proper explanation about the content of these files can be found from Dr. Anis Kouba’s tutorial I mentioned earlier. and finally the output path should be given as a vector.</p><p>You can find the template files from my <a href="https://github.com/ShaluthaRajapakshe/dstar_lite_planner.git" rel="noopener"><strong>Github</strong></a> repo.</p><p>Now we have completed writing our global path planner class. So we should compile it now. For that, add the following line to your newly created package’s <strong>CMakeLists.txt </strong>file.</p><!--kg-card-begin: html--><script src="https://gist.github.com/ShaluthaRajapakshe/e394818c25b285ddfcd573b00d40b3d7.js"></script>
<!--kg-card-end: html--><p>Then in terminal go to catkin_ws directory and run catkin_make. Now you can see your library file created at the directory: <strong>/catkin_ws/devel/lib </strong>with the name<strong> libd_star_planner.so</strong></p><p>Now it is time to deploy our path planner as a plugin in ROS. For that first we should create the plugin description file, inside the package we created.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*c1941w9Jpf6XqgZ9pN_5IA.gif" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>Then the information about your plugin should be added to that file. Add the following information according to your planner’s details inside the plugin description file.</p><!--kg-card-begin: html--><script src="https://gist.github.com/ShaluthaRajapakshe/558de617f360067fb69ce523d2f8044e.js"></script><!--kg-card-end: html--><p>Rename the <strong>path</strong> with your created library file’s name inside the lib folder. Then change the <strong>name</strong> and<strong> type</strong> according to your path planner class and finally add a description describing your path planner plugin.</p><p>Now to finish the deploying process, we should register our path planner plugin created above. For that we should add the following code with the plugin description file’s name we created, into the package.xml file of our package.</p><!--kg-card-begin: html--><script src="https://gist.github.com/ShaluthaRajapakshe/f4d5e8cea2304c85e6fe736e69725c27.js"></script><!--kg-card-end: html--><p>Congratulations!. Now you have successfully deployed your path planner plugin in the ROS environment. For verification, type this command in your terminal and see whether your plugin is shown.</p><blockquote><strong>rospack plugins — attrib=plugin nav_core</strong></blockquote><p>Now you can add this plugin to any of your robot’s navigation stack and use it for navigation purposes. What you have to do is add the planner as shown in the following image as one your move_base package’s parameters.</p><figure class="kg-card kg-image-card"><img src="https://cdn-images-1.medium.com/max/800/1*afSjmAClyHfhWlXiyj1cJQ.jpeg" class="kg-image" alt="Writing your own path planning algorithm in ROS"></figure><p>In a future article I will explain the steps to add this plugin on Turtlebot3 - Waffle which is a famous robot among the ROS community.</p>]]></content:encoded></item><item><title><![CDATA[Setting up the environment needed to begin with STM32]]></title><description><![CDATA[This article will cover the basics you will need in order to start programming your STM32 boards]]></description><link>https://shalutharajapakshe.github.io/setting-up-the-environment-needed-to-begin-with-stm32/</link><guid isPermaLink="false">60bf98391e8c380da4467f24</guid><category><![CDATA[MCU Programming]]></category><dc:creator><![CDATA[Shalutha Rajapakshe]]></dc:creator><pubDate>Tue, 07 Apr 2020 18:30:00 GMT</pubDate><media:content url="https://shalutharajapakshe.github.io/content/images/2021/06/cover-1.jpg" medium="image"/><content:encoded><![CDATA[<hr><img src="https://shalutharajapakshe.github.io/content/images/2021/06/cover-1.jpg" alt="Setting up the environment needed to begin with STM32"><p>Hey guys,</p><p>So how are you guys? Hope you all are doing well.</p><p>From the last article, we told you that we will be looking into the programming side of STM32. But, we thought it would be much better for you guys, if we can give an idea about the hardware you need to do the programming with STM32 first. So today’s article will be about the hardware you needed to program a STM32, and the step by step guide to settle them with your PC.</p><p>So the topics for today are as follows.</p><p>1 - Choosing a STM32 chip/Development Board for learning purposes</p><p>2 - Methods of programming the STM32 chip/Development Board</p><p>3 - Installing STM32CubeIDE</p><h3 id="1-choosing-a-stm32-chip-development-board-for-learning-purposes">1 - Choosing a STM32 chip/Development Board for learning purposes</h3><p>As I mentioned in the previous post, the STM32F1 series and the STMF4 series are the most suitable series for a beginner. For a price of RS 700-1000 range, you can easily buy a STM32F103C8 Development Board in Sri Lanka. F4 series’s Nucleo Boards (having chips like STM32F401, STM32F411, etc) are a little bit high in cost in Sri Lanka. So because of the cost issue, we would recommend a STM32F103C8 board for testing purposes.</p><p>The chip we are using in our micromouse is STM32F405. The F4 series has a greater processing power and many other advantages (higher flash memory,SRAM, etc) than the F1 series, <strong>but it should be mentioned that we can use the STM32F103C8 board to check every sensor, actuator, etc. that we are using in our mouse</strong> . So that you don’t need to wait until you completely build your mouse, you can check every function you are planning to use in your mouse, using the STM32F103C8 board (Bluepill).</p><p>Following shows a STM32F103C8 Development Board (Bluepill) &amp; the chip (STM32F103C8) used in it</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/STM32-2.jpg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>STM32F103C8 Development Board</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/armchip-1.png" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>STM32F103C8 Chip</figcaption></figure><p>This one here is a STM32 Nucleo F411RE Development Board</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/NUCLEO-F411RE-3-1.jpg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>STM32 Nucleo F411RE Development Board</figcaption></figure><p>This is the STM32F405RGT6 chip (Chip we will be using in our mouse)</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/chip2.jpeg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>STM32F405RGT6 Chip&nbsp;</figcaption></figure><p>For this STM32 guide, the requirement of a STM32 development board or a built robot using a STM32 chip is mandatory.</p><h3 id="2-methods-of-programming-the-stm32-chip-development-board">2 - Methods of programming the STM32 chip/Development Board</h3><p>Have you guys ever heard about a STLink or a TTL?</p><p>Normally, there are two main ways of programming a STM32 chip.</p><p>1 - Using a STLink</p><p>2 - Using USB - TTL converter</p><p><strong>STLink</strong></p><p>Mainly there are 3 types of STLinks.</p><p>1 - Standard STLink</p><p>2 - STLink Dongle</p><p>3 - On Board STLink</p><p>This one here is a Standard STlink and is a bit more expensive than a STLink Dongle and also has more debugging functionalities than a STLink Dongle.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/stlink.jpeg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>Standard STlink</figcaption></figure><p>This is a STLink Dongle and it is the most popular STLink type because of the lower price (RS 650 - 700) than the other types.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/stlink-normal.jpeg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>STLink Dongle</figcaption></figure><p>Onboard STLinks comes along with Nucleo development boards as shown in the following picture and you can also use this STLink to program any other STM32 chip. The advantage of Nucleo boards is, you can use USB - Mini cable to directly program your board.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/stm32-marked.gif" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>STLink on Nucleo Development Board</figcaption></figure><p>There are 4 pins mainly required to program a STM32 chip using a STLink.</p><p>1 - VCC (Power pin)</p><p>2 - GND (Ground pin)</p><p>3 - SWCLK (Clock)</p><p>4 - SWDIO (Data)</p><p>Additionally there’s an optional pin called SWO. This pin is only available at Standard STLinks and does not come with STLink Dongles. The advantage of this pin is it can be used to trace data.</p><p>Wiring diagram of a STLink dongle with STM32F103C8(Bluepill) Development Board is as follows.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/wire.png" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>Wiring diagram of a STLink dongle with STM32F103C8</figcaption></figure><p>In our STM32 guide, we will be using STM32CubeIDE to program our mouse and you can use any one of the three STLinks that we have mentioned above to program your STM32 chip using STM32CubeIDE.</p><p><strong>TTL</strong></p><p>Here is an USB - TTL converter programmer.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/TTl.jpeg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>USB - TTL converter&nbsp;</figcaption></figure><p>When using this, the communication happens through UART protocol. So you need to connect pins in your TTL programmer with STM32F103C8 Development Board as follows.</p><figure class="kg-card kg-image-card"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/table.png" class="kg-image" alt="Setting up the environment needed to begin with STM32"></figure><p>(* If you’re powering the STM32 board using TTL, this is required. Otherwise it is not needed)</p><p>This picture shows the wiring.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/Real-wiring.jpeg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>Wiring Diagram</figcaption></figure><p>But you need to be aware of one thing when using this method. Make sure the boot 0 jumper pin on the board is set to 1 (programming mode) while uploading the boot loader. Once the boot loader is flashed this pin can be changed back to initial position (operating mode).</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/board-marked.jpeg" class="kg-image" alt="Setting up the environment needed to begin with STM32"><figcaption>Modes in Bluepill</figcaption></figure><p>To use this method to program a STM32 chip using STM32CubeIDE, you need an additional software called STM32 Flash Loader Demonstrator.</p><p>What actually happens is, first you write your code in STM32CubeIDE and get the .bin file or .hex file and then using STM32 Flash Loader, you can upload it to the STM32 chip.</p><p>It should be noted that using this method, you cannot debug your program using CubeIDE.</p><p>You can download STM32 Flash Loader Demonstrator using this link</p><ul><li><a href="https://www.st.com/en/development-tools/flasher-stm32.html">https://www.st.com/en/development-tools/flasher-stm32.html</a></li></ul><h3 id="3-installing-stm32cubeide">3 - Installing STM32CubeIDE</h3><p>Now, you have a STM32 chip/Development Board and a suitable programmer ready with you. Next step is installing the editor required to edit your code. We are using STM32CudeIDE as our editor and it is required that you also have the same if you are following this guide.</p><p>You can download STM32CubeIDE using this link as we mentioned in the previous post</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://www.st.com/en/development-tools/stm32cubeide.html"><div class="kg-bookmark-content"><div class="kg-bookmark-title">STM32CubeIDE - STMicroelectronics</div><div class="kg-bookmark-description">STM32CubeIDE - Integrated Development Environment for STM32, STM32CubeIDE-RPM, STM32CubeIDE-Lnx, STM32CubeIDE-Win, STM32CubeIDE-DEB, STM32CubeIDE-Mac, STMicroelectronics</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://www.st.com/etc/clientlibs/st-site/media/app/images/favicon-32.png" alt="Setting up the environment needed to begin with STM32"><span class="kg-bookmark-publisher">STMicroelectronics</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://www.st.com/content/dam/logos/open-graph-logo.png" alt="Setting up the environment needed to begin with STM32"></div></a></figure><p><strong>If you’re planning to download more products from ST, it will become easier if you have an account. Creating an account is absolutely free.</strong></p><p>So see you guys.</p><p>Cheers!</p>]]></content:encoded></item><item><title><![CDATA[Introduction to STM32]]></title><description><![CDATA[STM32 micrpcontrollers are one of the most famous microcontrollers around the world. In this article I will give you an introduction to amazing thing.]]></description><link>https://shalutharajapakshe.github.io/introduction-to-stm32/</link><guid isPermaLink="false">60bf8ddc1e8c380da4467eef</guid><category><![CDATA[MCU Programming]]></category><dc:creator><![CDATA[Shalutha Rajapakshe]]></dc:creator><pubDate>Thu, 02 Apr 2020 18:30:00 GMT</pubDate><media:content url="https://shalutharajapakshe.github.io/content/images/2021/06/covernew.jpeg" medium="image"/><content:encoded><![CDATA[<img src="https://shalutharajapakshe.github.io/content/images/2021/06/covernew.jpeg" alt="Introduction to STM32"><p></p><p>Hey guys,</p><p>So let’s get started with STM32. Today we will be looking into the first part of this STM32 guide and it is just the introduction. This guide will be very useful for beginners who wants to get their hands dirty with STM32 micro-controllers. So keep follow us with this guide.</p><p>STM32 is actually not a specific micro-controller, it is a name given by STMicroelectronics to their ARM Cortex-M based micro-controller family.</p><p>STM32 family can be mainly divided into 4 groups.<br>		1 - High Performance (STM32F2 series, STM32F4 series, STM32F7 series, STM32H7 series, etc.)<br>		2 - Mainstream (STM32F0 series, STM32F1 series, STM32F3 series, etc.)<br>		3 - Wireless (STM32WB series, etc.)<br>		4 - Ultra Low Power (STM32L0 series, STM32L1 series, STM32L4 series, STM32L4+ series, STM32L5 series, etc.)</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/STM32-1.jpg" class="kg-image" alt="Introduction to STM32"><figcaption>STM32F103C8 Development Board (Bluepill)</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/NUCLEO-F411RE-3-1-.jpg" class="kg-image" alt="Introduction to STM32"><figcaption>STM32F411RE NUCLEO Development Board</figcaption></figure><h3 id="why-stm32">Why STM32?</h3><p>1 - Comparison with Atmega328 with STM32F103</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/comparison.png" class="kg-image" alt="Introduction to STM32"><figcaption>Comparison between Atmega328 and STM32F103</figcaption></figure><p>You can see how STM32F1 series performs way better than ATmega328. Not only this, the prize is also reasonable, like you can get STM32F103 chip for RS 250 – 300, while ATmega328 will cost around RS 350 – 400.</p><p>2 - Has a great graphical tool called CubeIDE for HAL (Explained in the latter part of this post) drivers which generates the startup code.</p><p>3 - Functionalities are high.</p><p>4 - 5V Tolerant - This means STM32s are capable of accepting 5V on their inputs.</p><p>5 - Pin to pin compatibility -  This means pins of a one chip are mostly identical to those of other chips. So that you can swap STM32 chips with your designs very easily according to the need. Still, attention needs to be paid for some pins like supply pins and regulator caps.</p><p>6 - More resources are available to help you with your projects.</p><h3 id="picking-a-microcontroller">Picking a microcontroller</h3><p>The STM32 family consists of many different microcontrollers, so that it will be hard for a beginner to choose one. But luckily most basic things that a beginner should learn are common to all microcontrollers in the STM32 family.</p><p>But there are two series that are better suited for a beginner than the other series. Those are the STM32F1 series and the STM32F4 series. Reason is Both series are around for a long time and are still popular among hobbyists. This means that there are a lot of resources available for devices in these series. Also, the devices in the STM32F1 series are not as complex as most other chips.</p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/mcu_1.png" class="kg-image" alt="Introduction to STM32" srcset="https://shalutharajapakshe.github.io/content/images/size/w600/2021/06/mcu_1.png 600w, https://shalutharajapakshe.github.io/content/images/2021/06/mcu_1.png 800w" sizes="(min-width: 720px) 720px"><figcaption>View of STM32F103 chip in CubeIDE</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/mcu_02.jpeg" class="kg-image" alt="Introduction to STM32" srcset="https://shalutharajapakshe.github.io/content/images/size/w600/2021/06/mcu_02.jpeg 600w, https://shalutharajapakshe.github.io/content/images/2021/06/mcu_02.jpeg 658w"><figcaption>View of STM32F411 chip in CubeIDE</figcaption></figure><h3 id="usable-ides">Usable IDEs</h3><p>IDE means Integrated Development Environment and when installed, they install all needed software like compilers and drivers needed for programming.</p><p>Some IDEs can be used free of charge while some require a license to be bought. Some famous IDEs that use for STM32 programming are listed below.</p><p>a) <strong>STM32CubeIDE</strong><br>b) <strong>Arm Keil MDK</strong><br>c) <strong>Eclipse</strong><br>d) <strong>SW4STM32</strong><br>e) <strong>Atollic TrueSTUDIO</strong><br>f) <strong>Segger Embedded Studio</strong></p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://shalutharajapakshe.github.io/content/images/2021/06/cubeide_1.jpeg" class="kg-image" alt="Introduction to STM32" srcset="https://shalutharajapakshe.github.io/content/images/size/w600/2021/06/cubeide_1.jpeg 600w, https://shalutharajapakshe.github.io/content/images/size/w1000/2021/06/cubeide_1.jpeg 1000w, https://shalutharajapakshe.github.io/content/images/2021/06/cubeide_1.jpeg 1280w" sizes="(min-width: 720px) 720px"><figcaption>View of CubeIDE</figcaption></figure><h3 id="platforms">Platforms</h3><p>Platforms offer their own APIs for controlling a device. Mainly there are two available platforms available for stm32 microcontrollers.</p><p>a) <strong>STM32duino</strong> - This one implements the Arduino API for STM32 microcontrollers and it can be used with Arduino IDE.</p><p>b) <strong>ARM Mbed </strong>- This platform not only supports STM32 microcontrollers but also supports a wide range of devices from different vendors. Mbed includes an OS specifically developed for IoT applications. It has both a cloud based IDE and a downloadable one.</p><h3 id="introduction-to-hal-hardware-abstraction-layer-">Introduction to HAL (Hardware Abstraction Layer)</h3><p>Hardware abstraction layer is a layer of programming in an operating system that allows to interact with hardware at a general or abstract level rather than a detailed hardware level. Simply, a hardware platform which can run applications. When HAL is employed, applications do not need to access hardware directly. They can access hardware through the abstract layer provided by HAL.</p><p>The HAL drivers designed by STMicroelectronics, offer a rich set of APIs to interact hardware easily with the application upper layers. The STM32Cube package comes with ready to use project templates, one for each supported board. Each of these project template provides empty main loop function and can be used as a starting point to get familiar with project settings for STM32Cube. Because of this, the code used for a STM32 can easily ported to any other STM32 with minor effort, as long as the required hardware functionality is there.</p><p><strong>Benefits of using HAL</strong></p><p>a)Allowing applications to extract as much performance out of the hardware devices as possible.</p><p>b)Enabling device drivers to provide direct access to each hardware device, which allows programs to be device independent.<br>c)Allowing software programs to communicate with the hardware devices at a general level.<br>d)Portability facility as mentioned above.</p><p>That’s all for the introduction part. Next time we will be looking into the programming of STM32 using STM32CubeIDE.</p><p>You can download STM32CubeIDE using this site,</p><ul><li><a href="https://www.st.com/en/development-tools/stm32cubeide.html">https://www.st.com/en/development-tools/stm32cubeide.html 6</a></li></ul><p>To get some basic understanding about STM32CubeIDE follow this URL.</p><ul><li><a href="https://www.digikey.com/en/maker/projects/getting-started-with-stm32-introduction-to-stm32cubeide/6a6c60a670c447abb90fd0fd78008697">https://www.digikey.com/en/maker/projects/getting-started-with-stm32-introduction-to-stm32cubeide/6a6c60a670c447abb90fd0fd78008697</a></li></ul><p>When programming in STM32CubeIDE, knowledge in C++ will be helpful. So for those who are not familiar with C++, you can start learning C++ using following courses or any other way that you like.</p><ul><li><a href="https://courses.edx.org/courses/course-v1:Microsoft+DEV210x+1T2018a/course/">https://courses.edx.org/courses/course-v1:Microsoft+DEV210x+1T2018a/course/ 8</a></li><li><a href="https://courses.edx.org/courses/course-v1:Microsoft+DEV210.2x+1T2018/course/">https://courses.edx.org/courses/course-v1:Microsoft+DEV210.2x+1T2018/course/ 2</a></li></ul>]]></content:encoded></item></channel></rss>